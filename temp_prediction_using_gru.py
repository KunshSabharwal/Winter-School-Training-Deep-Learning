# -*- coding: utf-8 -*-
"""Temp_prediction_using_LSTM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/196IZ5bqS8E40vrk0NPS8PkTQ7fRuIOkZ
"""

import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from sklearn.preprocessing import MinMaxScaler

# Step 1: Create a Simple Toy Dataset (daily temperatures)
temperature_data = np.array([30, 32, 35, 31, 29, 30, 28, 27, 26, 25, 24, 23, 22, 23, 25, 28, 30, 32, 34, 36, 37])

# Step 2: Normalize the Data (MinMax Scaling)
scaler = MinMaxScaler(feature_range=(0, 1))
temperature_data_scaled = scaler.fit_transform(temperature_data.reshape(-1, 1))

# Step 3: Prepare the Data for Training
# We use the past 3 days' temperature to predict the next day's temperature.
sequence_length = 3
X = []
y = []

for i in range(sequence_length, len(temperature_data_scaled)):
    X.append(temperature_data_scaled[i-sequence_length:i, 0])  # Previous 3 days' temperatures
    y.append(temperature_data_scaled[i, 0])  # Next day's temperature

X = np.array(X)
y = np.array(y)

# Reshape X for LSTM: (samples, timesteps, features)
X = X.reshape(X.shape[0], X.shape[1], 1)

# Step 4: Build the LSTM Model
model = Sequential([
    LSTM(50, return_sequences=False, input_shape=(X.shape[1], 1)),  # LSTM layer with 50 units
    Dense(1)  # Output layer
])

# Compile the model
model.compile(loss='mean_squared_error', optimizer='adam')

# Step 5: Train the Model
model.fit(X, y, epochs=200, batch_size=16, verbose=2)

# Step 6: Predict the Next Temperature
last_sequence = temperature_data_scaled[-sequence_length:].reshape(1, sequence_length, 1)
predicted_temperature_scaled = model.predict(last_sequence)

# Step 7: Reverse the Scaling
predicted_temperature = scaler.inverse_transform(predicted_temperature_scaled)
print(f"Predicted next day's temperature: {predicted_temperature[0][0]} °C")

# Step 8: Plotting the Results
plt.plot(temperature_data, label='Actual Temperature')
plt.plot(np.arange(len(temperature_data), len(temperature_data)+1), predicted_temperature, label='Predicted Temperature', marker='o', color='red')
plt.legend()
plt.xlabel('Day')
plt.ylabel('Temperature (°C)')
plt.title('Temperature Prediction using LSTM')
plt.show()

import numpy as np
import pandas as pd
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import GRU, Dense
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

# Step 1: Generate a simple dataset (daily temperature data)
# For example, let's generate 100 days of temperature data with a pattern
days = 100
np.random.seed(42)
temperature_data = np.sin(np.linspace(0, 20, days)) + np.random.normal(0, 0.1, days)

# Create a DataFrame for better visualization
df = pd.DataFrame(temperature_data, columns=["Temperature"])
plt.plot(df)
plt.title('Temperature Data')
plt.xlabel('Days')
plt.ylabel('Temperature')
plt.show()

# Step 2: Preprocess the data (Scaling and preparation for GRU)
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(df.values)

# Prepare the data for training (using the last 7 days to predict the next day's temperature)
X = []
y = []

for i in range(7, len(scaled_data)):
    X.append(scaled_data[i-7:i, 0])  # Last 7 days
    y.append(scaled_data[i, 0])  # Next day's temperature

X = np.array(X)
y = np.array(y)

# Reshape X for GRU input (samples, time steps, features)
X = X.reshape(X.shape[0], X.shape[1], 1)

# Step 3: Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Step 4: Build the GRU model
model = Sequential([
    GRU(50, return_sequences=False, input_shape=(X_train.shape[1], 1)),  # GRU layer with 50 units
    Dense(1)  # Output layer
])

# Step 5: Compile and train the model
model.compile(optimizer='adam', loss='mean_squared_error')
model.fit(X_train, y_train, epochs=20, batch_size=8, verbose=2)

# Step 6: Predict the temperature for the test data
predictions = model.predict(X_test)

# Step 7: Inverse transform the predictions back to the original scale
predictions = scaler.inverse_transform(predictions)
y_test = scaler.inverse_transform(y_test.reshape(-1, 1))

# Step 8: Plot the results
plt.plot(y_test, label='True Temperatures')
plt.plot(predictions, label='Predicted Temperatures')
plt.title('Temperature Prediction')
plt.xlabel('Days')
plt.ylabel('Temperature')
plt.legend()
plt.show()